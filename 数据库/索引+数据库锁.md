[TOC]

# 数据库

## 索引

### 1.为什么要使用索引

* 避免全表扫描查找数据，提升检索速率

### 2.什么样的信息能作为索引

* 主键，唯一键，普通键等让数据具备一定区分性的字段

### 3.索引的数据结构

* 生成索引，建立**二叉查找树**进行二分查找

  ```markdown
  时间复杂度 O(logn)
  ```

* 生成索引，建立**B-Tree**结构进行查找

* 生成索引，建立**B+-Tree**结构进行查找

  ```markdown
  B+树更适合做存储索引
  	1.B+树的磁盘读写代价更低
  	2.B+树的查询效率更加稳定
  	3.B+树更有利于对数据库的扫描
  ```

* 生成索引，建立Hash结构进行查找

  ```markdown
  缺点：
  	1.仅能满足“=”，“IN”,不能使用范围查询 
  	2.无法被用来避免数据的排序操作 
  	（1,2的原因：比较的是进行Hash运算之后的值，不能保证与Hash处理之前的值一致）
  	3.不能利用部分索引键查询 (不能利用主合索引：主合键合并之后再进行Hash)
  	4.不能避免表扫描 （不同索引键存在相同Hash值）
  	5.遇到大量Hash值相同的情况后性能不一定比B+-Tree索引高
  ```

* 生成索引，BitMap

### 4.索引类型

密集索引和稀疏索引的区别：

 * 密集索引文件中的每个搜索码值都对应一个索引值
 * 稀疏索引文件中只为索引码的某些值建立索引项

```markdown
InnoDB引擎(使用密集索引)：
  主键组织到一颗B+树中，行数据存在叶子节点上；主键索引和对应数据保存在同一个文件中。  
	1.若一个主键被定义，则主键被作为密集索引
	2.若没有主键则选择一个唯一非空索引为密集索引
	3.若都没有，会生成一个隐藏索引作为密集索引
MyISAM引擎（使用稀疏索引）：
  索引和数据分开存储在两个文件。
  非主键索引(稀疏索引)并不存储行数据的物理地址，存储的是该行的主键值；所以非主键索引包含两次查找，一次找次级索引自身，再查找主键
```

### 5. 如何优化慢查询sql

* 查询慢日志

  ```markdown
  show variables like '%quer%'
    关注三个变量：slow_xxx 和 long_query_time
    打开慢日志：`set global slow_query_log = on`
    设置查询时间： `set global long_query_time = 1`
  show status like '%slow_queries%'  慢日志条数
  ```

* 使用explain等工具分析sql

  ```markdo
  explain 后面接sql
    关注两个字段type和extra
    type：表示找到数据行的方式，all和index时表示全表查询，需要优化
    extra：关注using filesort和using temporary，出现时表示没有使用索引，需要优化
  ```

* 修改sql或让sql走索引

  ```markdown
  alter table 表名 add index idx_name(字段名)
  
  select xx from 表名 force index(primary) ：强制使用索引
  ```

### 6.联合索引的最左匹配原则

```markdown
建表时： key ‘index_area_titile’(‘area’,‘title’)  联合索引
	查询时会一直向右匹配直到遇到范围查询(>,<,like,between)就停止匹配，后面的条件就用不到索引了
最左匹配原则成因：创建联合索引时，会先对最左的字段排序，然后依次向右。B+树结构，先找到父节点才有子节点。因此，直接以非第一个字段作为条件判断是用不到索引的。
```

### 7.索引建的越多越好吗

* 数据量小的表不需要建立索引，建立会增加额外的索引开销
* 数据变更需要维护索引，更多的索引意味着更多的维护成本
* 更多的索引意味着需要更多的空间

## 锁

### 1.MyISAM与InnoDB关于锁方面的区别

* MyISAM默认使用表级锁(锁住整张表)，不支持行级锁

  > MyISAM： 查询时会加上表级的读锁，增删改时会加上表级写锁
  >
  > 加上读(写)锁：`lock tables 表名 read(write)`  释放锁：`unlock tables`

  读锁又称共享锁(上了共享锁后，其他会话也可以上共享锁)；写锁又称排他锁(只能有一个锁)；

* InnoDB默认使用行级锁，也支持表级锁（在SQL没有用到索引的时候用表级锁）

  > 使用的是二段锁，加锁和解锁分成两个步骤
  >
  > MySQL默认自动提交： `show variables like 'autocommit'`
  >
  > 给select语句上锁： 写锁:`selecet xx for update`   读锁:`select xx lock in share mode`

### 2.数据库事务四大特性

**ACID**

* 原子性(Atomic)：

  一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

* 一致性(Consistency)：

  在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。

* 隔离性(Isolation)

  数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。

  事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。

* 持久性(Durability)

  事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失

### 3.事务隔离级别以及并发访问问题

* 不可更新读(一个事务的更新覆盖了另一个事务的更新)：MySQL所有事务隔离级别**在数据库层面**均可避免

* 脏读(一个事务读到另一个事务未提交的更新数据)：read-committed事务隔离级别可避免

* 不可重复读(一个事务的两次读数据之间，由于另一个事务的修改，导致事务两次读到的的数据不一样)：

  repeatable-read事务隔离级别可避免     

* 幻读(一个事务在读取数据时，由于另一事务的新增和删除数据，发现数据行出现变化)：

  Serializable事务隔离级别可避免

### 4.InnoDB可重复读隔离级别下如何避免幻读

* 当前读：加了锁的select和增删改等操作。当前读读的是数据的最新版本，并保证并发事务不能修改当前记录
* 快照读：不加锁的select(非Serializable级别).创建快照的时间，决定了数据版本

### 5.RC、RR级别下InnoDB的非阻塞读如何实现



